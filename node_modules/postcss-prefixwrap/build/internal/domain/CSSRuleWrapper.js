"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixWrapCSSSelector = exports.prefixWrapCSSRule = void 0;
const CSSSelector_1 = require("./CSSSelector");
const prefixWrapCSSRule = (cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags, prefixTransform) => {
    // Check each rule to see if it exactly matches our prefix selector, when
    // this happens, don't try to prefix that selector.
    const rules = cssRule.selectors.filter((selector) => !(0, CSSSelector_1.cssRuleMatchesPrefixSelector)({ selector: selector }, prefixSelector));
    if (rules.length === 0) {
        return;
    }
    cssRule.selector = rules
        .map((cssSelector) => (0, exports.prefixWrapCSSSelector)(cssSelector, cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags, prefixTransform))
        .filter(CSSSelector_1.isValidCSSSelector)
        .join(", ");
};
exports.prefixWrapCSSRule = prefixWrapCSSRule;
const prefixWrapCSSSelector = (cssSelector, cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags, prefixTransform) => {
    const cleanedSelector = (0, CSSSelector_1.cleanSelector)(cssSelector);
    if (cleanedSelector === "") {
        return null;
    }
    // Don't prefix nested selected.
    if (nested !== null && cleanedSelector.startsWith(nested, 0)) {
        return cleanedSelector;
    }
    // Do not prefix keyframes rules.
    if ((0, CSSSelector_1.isKeyframes)(cssRule)) {
        return cleanedSelector;
    }
    // Check for matching ignored selectors
    if (ignoredSelectors.some((currentValue) => {
        if (currentValue instanceof RegExp) {
            return cleanedSelector.match(currentValue);
        }
        return cleanedSelector === currentValue;
    })) {
        return cleanedSelector;
    }
    // Anything other than a root tag is always prefixed.
    if ((0, CSSSelector_1.isNotRootTag)(cleanedSelector)) {
        if (prefixTransform) {
            return prefixTransform(cleanedSelector, prefixSelector);
        }
        else {
            return prefixSelector + " " + cleanedSelector;
        }
    }
    // Handle special case where root tags should be converted into classes
    // rather than being replaced.
    if (prefixRootTags) {
        if (prefixTransform) {
            // When prefixTransform is defined, we provided cleanedSelector
            // without the additional "." prepended.
            return prefixTransform(cleanedSelector, prefixSelector);
        }
        else {
            return prefixSelector + " ." + cleanedSelector;
        }
    }
    // HTML and Body elements cannot be contained within our container so lets
    // extract their styles.
    return cleanedSelector.replace(/^(body|html|:root)/, prefixSelector);
};
exports.prefixWrapCSSSelector = prefixWrapCSSSelector;
